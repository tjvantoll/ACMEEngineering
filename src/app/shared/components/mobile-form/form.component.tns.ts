//-------------------------------------------------------------------------
// <Auto-generated file - do not modify!>
//
// This code was generated automatically by Kinvey Studio.
//
// Changes to this file may cause undesired behavior and will be lost
// the next time the code regenerates.
//
// Find more information on https://devcenter.kinvey.com/guides/studio-extension-points.
//-------------------------------------------------------------------------
import { Component, NgZone, OnInit, ViewChild, ElementRef, Input, OnDestroy, Injector } from '@angular/core';
import { FormGroup, ValidatorFn, AsyncValidatorFn, AbstractControlOptions } from '@angular/forms';
import { ActivatedRoute } from '@angular/router';
import { Subscription } from 'rxjs';
import { View, ViewBase } from 'tns-core-modules/ui/core/view/view';
import { alert } from 'tns-core-modules/ui/dialogs';
import { ExtendedNavigationExtras } from 'nativescript-angular/router/router-extensions';

import { StringUtilsService } from "@src/app/core/services/string-utils.service";
import { EntityDataService } from '@src/app/core/data/entity-data.service';
import { Label } from 'tns-core-modules/ui/label';
import { NavigationService } from '@src/app/core/services/navigation.service';
import { LayoutBase } from 'tns-core-modules/ui/layouts/layout-base';

export interface FormValidationMessages {
    required?: string;
    requiredtrue?: string;
    min?: string;
    max?: string;
    minlength?: string;
    maxlength?: string;
    email?: string;
    pattern?: string;
    [key: string]: string;
}

export interface FormControlOptions extends AbstractControlOptions {
    validators: ValidatorFn[];
    asyncValidators: AsyncValidatorFn[];
    initial?: any
    messages: FormValidationMessages,
}

export interface FormGroupConfig {
    [key: string]: FormControlOptions;
}

export interface FormConfig {
    validationMessages: FormValidationMessages;
    groups: {
        [key: string]: FormGroupConfig;
    };
    onSubmit?: ({ form: KSFormComponent }) => Promise<void> | void;
    onCancel?: ({ form: KSFormComponent }) => Promise<void> | void;
    onBeforeSubmit?: ({ form: KSFormComponent, item: any, cancelled: boolean }) => Promise<void> | void;
    onSubmitSave?: ({ form: KSFormComponent, item: any }) => Promise<{ _id: string }> | { _id: string };
    onAfterSubmit?: ({ form: KSFormComponent, result: any }) => Promise<void> | void;
    afterSubmitNavigateTo?: { allowBackNavigation: boolean; module: string; view: string; [key: string]: any; };
}

export function getDefaultValidationMessages(): FormValidationMessages {
    return {
        required: '${fieldName} is required',
        requiredtrue: '${fieldName} is required to be true',
        min: '${fieldName} should be minimum ${min}',
        max: '${fieldName} should be maximum ${max}',
        minlength: '${fieldName} minimum length is ${requiredLength}',
        maxlength: '${fieldName} maximum length is ${requiredLength}',
        email: '${fieldName} should be a valid email',
        pattern: '${fieldName} should match the pattern'
    };
}

export function getDefaultControlOptions(initial: any): FormControlOptions {
    return {
        validators: Array<ValidatorFn>(),
        asyncValidators: Array<AsyncValidatorFn>(),
        updateOn: 'change',
        initial,
        messages: {}
    };
}

@Component({
    selector: 'ks-form',
    templateUrl: './form.component.html',
})
export class KSFormComponent implements OnInit, OnDestroy {
    private zone: NgZone;
    private activatedRoute: ActivatedRoute;
    private navigationService: NavigationService;
    private stringUtilsService: StringUtilsService;
    private subscriptions: Subscription[] = [];

    @ViewChild('formContainer') public formContainer: ElementRef;

    @Input() public config: FormConfig;
    @Input() public dataService: EntityDataService<any>;
    @Input() public formGroup: FormGroup;
    @Input() public groupName: string;

    public asyncInputs: Promise<void>[] = [];
    public item = {};
    public originalItem = {};
    public isLoading = false;

    constructor(public injector: Injector) {
        this.zone = injector.get(NgZone);
        this.activatedRoute = injector.get(ActivatedRoute);
        this.navigationService = injector.get(NavigationService);
        this.stringUtilsService = injector.get(StringUtilsService);
    }

    ngOnInit() {
        this.initForm(this.formContainer.nativeElement.content, this.formGroup);

        if (!this.dataService) {
            return;
        }

        this.subscriptions.push(this.dataService.dataChanges
            .subscribe((item) => {
                if (!item) {
                    return;
                }

                this.originalItem = item;
                this.formGroup.patchValue(item);
            }));
    }

    ngOnDestroy() {
        this.subscriptions.forEach(sub => sub.unsubscribe());
        this.subscriptions = [];
    }

    initForm(formView: View, formGroup: FormGroup): void {
        const setupView = (view: ViewBase) => {
            const element = view as any;

            const type = element.buttonType === 'SubmitAndUpdate' ? 'Submit' : element.buttonType;
            if (type) {
                element.firstChild.on('tap', this[`on${type}`], this);
            }

            if (element.formControlName) {
                setupValidationMessages(view as View, element.formControlName);
            }

            view.eachChild(<any>(child => setupView(child)));
        };

        const setupValidationMessages = (view: View, controlName: string) => {
            const getLayoutParent = (view: ViewBase): LayoutBase => {
                return view.parent instanceof(LayoutBase) ? view.parent : view.parent && getLayoutParent(view.parent);
            }

            const parent = getLayoutParent(view);
            if (!parent) {
                console.error(`Failed to set validation message for ${controlName}!`);
                return;
            }

            const customProps = (view as any) as { __validationMessage: Label };
            const formControl = formGroup.controls[controlName];

            const subscription = formControl.statusChanges.subscribe((status) => {
                if (status === 'VALID') {
                    if (customProps.__validationMessage && parent) {
                        parent.removeChild(customProps.__validationMessage);
                    }

                    return;
                }

                const [errorName] = Object.keys(formControl.errors);
                const errorData = formControl.errors[errorName];

                if (!customProps.__validationMessage) {
                    customProps.__validationMessage = new Label();
                } else if (customProps.__validationMessage.parent) {
                    parent.removeChild(customProps.__validationMessage);
                }

                customProps.__validationMessage.className = 'form__validation-message';

                const index = parent.getChildIndex(view);

                parent.insertChild(customProps.__validationMessage, index + 1);

                const fieldName = controlName[0].toUpperCase() + controlName.substr(1);
                const params = Object.assign({ fieldName }, errorData);
                const formGroupConfig = this.config.groups[this.groupName];
                const messages = Object.assign({}, this.config.validationMessages, formGroupConfig[controlName].messages)
                const template = view[`${errorName}Message`] || messages[errorName];

                customProps.__validationMessage.text = this.stringUtilsService.interpolate(template, params);
            });

            this.subscriptions.push(subscription);
        };

        formView.eachChild(<any>(view => setupView(view)));
    }

    get isValid() {
        return this.formGroup.valid;
    }

    onSubmit() {
        if (this.config.onSubmit) {
            this.config.onSubmit({ form: this });
            return;
        }

        this.zone.run(() => this.isLoading = true);
        const beforeSubmitArgs = { form: this, item: null, cancelled: false };
        Promise.all(this.asyncInputs)
            .then(() => {
                if (!this.isValid) {
                    Object.keys(this.formGroup.controls).forEach(key => {
                        const control = this.formGroup.get(key);

                        control.updateValueAndValidity({ onlySelf: true });
                        control.markAsDirty();
                    });

                    throw new Error('The form is not valid.');
                }

                this.item = { ...this.originalItem, ...this.formGroup.value };
            })
            .then(() => {
                if (this.config.onBeforeSubmit) {
                    beforeSubmitArgs.item = this.item;
                    return this.config.onBeforeSubmit(beforeSubmitArgs);
                }
            })
            .then(() => {
                if (beforeSubmitArgs.cancelled) {
                    this.zone.run(() => this.isLoading = false);
                    return;
                }
            })
            .then(() => {
                if (this.config.onSubmitSave) {
                    return this.config.onSubmitSave({ form: this, item: this.item });
                }

                return this.dataService.save(this.item);
            })
            .then((result) => {
                if (this.config.afterSubmitNavigateTo) {
                    const command = [this.config.afterSubmitNavigateTo.module, this.config.afterSubmitNavigateTo.view];
                    const extras: ExtendedNavigationExtras = {
                        relativeTo: this.activatedRoute,
                        queryParams: {
                            [this.dataService.queryIdParam]: result._id
                        },
                        clearHistory: !this.config.afterSubmitNavigateTo.allowBackNavigation
                    };
                    const preserveQueryParams = true;

                    return this.navigationService.navigate(command, extras, preserveQueryParams);
                } else if (this.config.onAfterSubmit) {
                    return this.config.onAfterSubmit({ form: this, result })
                }

                return this.navigationService.goBack(this.activatedRoute);
            })
            .catch((err) => {
                alert(err && err.message || 'An error has occurred.');
            })
            .then(() => {
                this.zone.run(() => this.isLoading = false);
            });
    }

    onCancel() {
        if (this.config.onCancel) {
            this.config.onCancel({ form: this });
            return;
        }

        return this.navigationService.goBack(this.activatedRoute);
    }

    onRegisterAsyncInput(asyncInput: Promise<void>) {
        this.asyncInputs.push(asyncInput);
    }
}
